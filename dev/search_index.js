var documenterSearchIndex = {"docs":
[{"location":"#AffineMotions.jl","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Affine motions are functions from a space to a Lie group fulfilling the affine condition.","category":"page"},{"location":"#General-Interface","page":"AffineMotions.jl","title":"General Interface","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Motion.jl\"]","category":"page"},{"location":"#AffineMotions.AffineMotion","page":"AffineMotions.jl","title":"AffineMotions.AffineMotion","text":"struct AffineMotion <: AbstractAffineMotion\n    A # action G -> Diff(M)\n    f # motion: M -> Alg(G)\n    lin # linear part: operator Alg(G) ⊗ Alg(G)*\nend\n\nGeneral affine motion, defined from an action of a group G on a manifold M, a dynamics f colon G to mathfrakg,  and the corresponding constant linear part lin, a linear endormorphism of mathfrakg.\n\n\n\n\n\n","category":"type"},{"location":"#AffineMotions.compose_adjoint-Tuple{Any, Any, Any, ManifoldsBase.AbstractBasis}","page":"AffineMotions.jl","title":"AffineMotions.compose_adjoint","text":"Compose the adjoint action with the matrix M, i.e., given M ∈ Alg(G) ⊗ Alg(G)*, the new operator is defined by ξ ↦ χ (Mξ) χ⁻¹ and the function returns the corresponding matrix.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.compute_morphism-Tuple{Any, Any, Any}","page":"AffineMotions.jl","title":"AffineMotions.compute_morphism","text":" compute_morphism(φ::Motion, x, B::AbstractBasis)\n\nIntegrate the lift of the motion φ at the point x, this gives a group element χ. This allows to compute the associate morphism, i.e., the operator\n\nξ  χ^-1 (exp(Dφ)ξ) χ\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.get_action-Tuple{AbstractMotion}","page":"AffineMotions.jl","title":"AffineMotions.get_action","text":"get_action(m::AbstractMotion) :: AbstractGroupAction\n\nThe action for the given motion.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.get_dynamics","page":"AffineMotions.jl","title":"AffineMotions.get_dynamics","text":"get_dynamics(::AbstractMotion, x) :: Alg(G)\n\nThe actual motion x -> φ(x) in Alg(G).\n\nShortcut: m(x) ≡ get_dynamics(m, x)\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.get_lin-Tuple{AffineMotions.AffineMotion}","page":"AffineMotions.jl","title":"AffineMotions.get_lin","text":"get_lin(m::AffineMotion) :: Function\n\nThe linear part of the motion, a linear endomorphism of mathfrakG.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.get_lin_at","page":"AffineMotions.jl","title":"AffineMotions.get_lin_at","text":"get_lin_at(φ::AbstractMotion, ::Any) :: Function\n\nThe linear operator ξ  dφξ_x+φ(x)ξ at the point x for motion φ.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.get_lin_mat-Tuple{AbstractMotion, Any, ManifoldsBase.AbstractBasis}","page":"AffineMotions.jl","title":"AffineMotions.get_lin_mat","text":"Compute matrix for Dφ in the given basis\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.integrate","page":"AffineMotions.jl","title":"AffineMotions.integrate","text":"integrate(motion, x0::TM) :: TM\n\nIntegrate the motion motion from the point x0 on the manifold.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.integrate_lift","page":"AffineMotions.jl","title":"AffineMotions.integrate_lift","text":"integrate_lift(m::AbstractMotion, x0) :: AbstractODESolution\n\nIntegrate the lifted motion in the acting group.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.morphism-Tuple{Any, Any, Any}","page":"AffineMotions.jl","title":"AffineMotions.morphism","text":" morphism(φ::Motion, x, B::AbstractBasis)\n\nReturn the Lie algebra morphism exp(Dφ), where Dφ is the linear part of the motion φ.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.rescale_motion","page":"AffineMotions.jl","title":"AffineMotions.rescale_motion","text":"rescale_motion(s::Number, φ::Motion) :: Typeof(φ)\n\nRescale the motion by s. This corresponds to the new motion (sφ)(x) = s(φ(x)). The motion φ is conveniently rescaled with the syntax s*φ.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.swap_group_motion-Tuple{RigidMotion{var\"#s14\", TV} where {var\"#s14\"<:(Manifolds.GroupOperationAction{Manifolds.LeftAction, Manifolds.LeftSide, G} where G<:ManifoldsBase.AbstractDecoratorManifold), TV}}","page":"AffineMotions.jl","title":"AffineMotions.swap_group_motion","text":"swap_group_motion(::Motion)\n\nSwap from standard to dual group action, while preserving the same dynamics.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{AbstractMotion, Any}","page":"AffineMotions.jl","title":"Base.:*","text":"Compute the tangent vector corresponding to the motion at the point x on the manifold.\n\n\n\n\n\n","category":"method"},{"location":"#Flat-Affine-Case","page":"AffineMotions.jl","title":"Flat Affine Case","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/FlatAffine.jl\"]","category":"page"},{"location":"#AffineMotions.FlatAffineMotion","page":"AffineMotions.jl","title":"AffineMotions.FlatAffineMotion","text":"FlatAffineMotion(A::Matrix,b::Vector)\n\nCreates the affine motion corresponding to the vector field x  A x + b.\n\nusing AffineMotions\nA = [0 1.;0 0]\nb = [0, 0]\nmotion = FlatAffineMotion(A,b)\n\nx0 = [2., 10] # position zero, velocity 10\nx1 = integrate(motion, x0)\n# output\n2-element Vector{Float64}:\n 12.0\n 10.0\n\n\n\n\n\n","category":"type"},{"location":"#AffineMotions.get_flat_action-Tuple{Any}","page":"AffineMotions.jl","title":"AffineMotions.get_flat_action","text":"get_flat_action(d)\n\nThe action associated to a flat space of dimension d, namely a translation group acting on a Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#Rigid-Motions","page":"AffineMotions.jl","title":"Rigid Motions","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/Rigid.jl\"]","category":"page"},{"location":"#AffineMotions.RigidMotion","page":"AffineMotions.jl","title":"AffineMotions.RigidMotion","text":" RigidMotion(action::Action, ξ)\n\nThe rigid motion action of a group on a manifold. The variable ξ is an element of the Lie algebra of the acting group base_group(action).\n\nThe corresponding vector field f at a point x of the manifold M (i.e., M := group_manifold(action)) is:\n\nf(x) = ξx\n\nwhere  represents the infinitesimal action defined by action.\n\n\n\n\n\n","category":"type"},{"location":"#AffineMotions.get_velocity","page":"AffineMotions.jl","title":"AffineMotions.get_velocity","text":" get_velocity(m::AbstractRigidMotion)\n\nAccess to the underlying infinitesimal motion defining the rigid motion m.\n\n\n\n\n\n","category":"function"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/Zero.jl\"]","category":"page"},{"location":"#AffineMotions.ZeroMotion","page":"AffineMotions.jl","title":"AffineMotions.ZeroMotion","text":"ZeroMotion(::GroupAction)\n\nTrivial rigid motion equal to zero everywhere.\n\n\n\n\n\n","category":"type"},{"location":"#Translations","page":"AffineMotions.jl","title":"Translations","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/Translation.jl\"]","category":"page"},{"location":"#AffineMotions.TranslationMotion-Tuple{Any, Any, Manifolds.GroupActionSide}","page":"AffineMotions.jl","title":"AffineMotions.TranslationMotion","text":"TranslationMotion(G, ξ, side=LeftSide())\n\nA translation motion φ  G  Alg(G) defined on Lie groups. There is a left and a right version.\n\nLeft: φ(χ) = -χξχ^-1.\nRight: φ(χ) = -χ^-1ξχ.\n\nIn both cases, the linear part is the zero operator.\n\n\n\n\n\n","category":"method"},{"location":"#Adjoint-Linear-Motion","page":"AffineMotions.jl","title":"Adjoint Linear Motion","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"../ext/AdjointLinearExt/AdjointLinear.jl\"]","category":"page"},{"location":"#Utilities","page":"AffineMotions.jl","title":"Utilities","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Utils.jl\"]","category":"page"},{"location":"#AffineMotions.pose_velocities-Tuple{Any, Any}","page":"AffineMotions.jl","title":"AffineMotions.pose_velocities","text":"pose_velocities(G, poses)\n\nTake a list χ_i and returns a list (χ_i v_i)  such that χ_i+1 = exp_χ_i(v_i)\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.rigid_motion-NTuple{4, Any}","page":"AffineMotions.jl","title":"AffineMotions.rigid_motion","text":"rigid_motion(G, χ, v, side)\n\nThe rigid motion starting at χ in the direction v (tangent to χ), using either the standard left action or the dual one.\n\n\n\n\n\n","category":"method"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"AffineMotions.AdjointLinearMotion","category":"page"},{"location":"#AffineMotions.AdjointLinearMotion","page":"AffineMotions.jl","title":"AffineMotions.AdjointLinearMotion","text":"AdjointLinearMotion(G::DecoratedManifold,M::Array{𝔽, 2},conv::ActionDirection)\n\nOne of the affine motions which are neither rigid motions nor translations on the group SE_k(n) (or more general affine groups). If a group element is denoted by χ = XR, then the motion corresponding to the kk matrix M is defined by φ(χ) = (XM^*0).\n\n\n\n\n\n","category":"type"}]
}
