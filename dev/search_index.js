var documenterSearchIndex = {"docs":
[{"location":"#AffineMotions.jl","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Affine motions are functions from a space to a Lie group fulfilling the affine condition.","category":"page"},{"location":"#General-Interface","page":"AffineMotions.jl","title":"General Interface","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Motion.jl\"]","category":"page"},{"location":"#AffineMotions.AffineMotion","page":"AffineMotions.jl","title":"AffineMotions.AffineMotion","text":"struct AffineMotion <: AbstractAffineMotion\n    A # action G -> Diff(M)\n    f # motion: M -> Alg(G)\n    lin # linear part: operator Alg(G) âŠ— Alg(G)*\nend\n\nGeneral affine motion, defined from an action of a group G on a manifold M, a dynamics f colon G to mathfrakg,  and the corresponding constant linear part lin, a linear endormorphism of mathfrakg.\n\n\n\n\n\n","category":"type"},{"location":"#AffineMotions.compose_adjoint-Tuple{Any, Any, Any, ManifoldsBase.AbstractBasis}","page":"AffineMotions.jl","title":"AffineMotions.compose_adjoint","text":"Compose the adjoint action with the matrix M, i.e., given M âˆˆ Alg(G) âŠ— Alg(G)*, the new operator is defined by Î¾ â†¦ Ï‡ (MÎ¾) Ï‡â»Â¹ and the function returns the corresponding matrix.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.compute_morphism-Tuple{Any, Any, Any}","page":"AffineMotions.jl","title":"AffineMotions.compute_morphism","text":" compute_morphism(Ï†::Motion, x, B::AbstractBasis)\n\nIntegrate the lift of the motion Ï† at the point x, this gives a group element Ï‡. This allows to compute the associate morphism, i.e., the operator\n\nÎ¾  Ï‡^-1 (exp(DÏ†)Î¾) Ï‡\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.get_action-Tuple{AbstractMotion}","page":"AffineMotions.jl","title":"AffineMotions.get_action","text":"get_action(m::AbstractMotion) :: AbstractGroupAction\n\nThe action for the given motion.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.get_dynamics","page":"AffineMotions.jl","title":"AffineMotions.get_dynamics","text":"get_dynamics(::AbstractMotion, x) :: Alg(G)\n\nThe actual motion x -> Ï†(x) in Alg(G).\n\nShortcut: m(x) â‰¡ get_dynamics(m, x)\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.get_lin-Tuple{AffineMotions.AffineMotion}","page":"AffineMotions.jl","title":"AffineMotions.get_lin","text":"get_lin(m::AffineMotion) :: Function\n\nThe linear part of the motion, a linear endomorphism of mathfrakG.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.get_lin_at","page":"AffineMotions.jl","title":"AffineMotions.get_lin_at","text":"get_lin_at(Ï†::AbstractMotion, ::Any) :: Function\n\nThe linear operator Î¾  dÏ†Î¾_x+Ï†(x)Î¾ at the point x for motion Ï†.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.get_lin_mat-Tuple{AbstractMotion, Any, ManifoldsBase.AbstractBasis}","page":"AffineMotions.jl","title":"AffineMotions.get_lin_mat","text":"Compute matrix for DÏ† in the given basis\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.integrate","page":"AffineMotions.jl","title":"AffineMotions.integrate","text":"integrate(motion, x0::TM) :: TM\n\nIntegrate the motion motion from the point x0 on the manifold.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.integrate_lift","page":"AffineMotions.jl","title":"AffineMotions.integrate_lift","text":"integrate_lift(m::AbstractMotion, x0) :: AbstractODESolution\n\nIntegrate the lifted motion in the acting group.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.morphism-Tuple{Any, Any, Any}","page":"AffineMotions.jl","title":"AffineMotions.morphism","text":" morphism(Ï†::Motion, x, B::AbstractBasis)\n\nReturn the Lie algebra morphism exp(DÏ†), where DÏ† is the linear part of the motion Ï†.\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.rescale_motion","page":"AffineMotions.jl","title":"AffineMotions.rescale_motion","text":"rescale_motion(s::Number, Ï†::Motion) :: Typeof(Ï†)\n\nRescale the motion by s. This corresponds to the new motion (sÏ†)(x) = s(Ï†(x)). The motion Ï† is conveniently rescaled with the syntax s*Ï†.\n\n\n\n\n\n","category":"function"},{"location":"#AffineMotions.swap_group_motion-Tuple{RigidMotion{var\"#s14\", TV} where {var\"#s14\"<:(Manifolds.GroupOperationAction{Manifolds.LeftAction, Manifolds.LeftSide, G} where G<:ManifoldsBase.AbstractDecoratorManifold), TV}}","page":"AffineMotions.jl","title":"AffineMotions.swap_group_motion","text":"swap_group_motion(::Motion)\n\nSwap from standard to dual group action, while preserving the same dynamics.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{AbstractMotion, Any}","page":"AffineMotions.jl","title":"Base.:*","text":"Compute the tangent vector corresponding to the motion at the point x on the manifold.\n\n\n\n\n\n","category":"method"},{"location":"#Flat-Affine-Case","page":"AffineMotions.jl","title":"Flat Affine Case","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/FlatAffine.jl\"]","category":"page"},{"location":"#AffineMotions.FlatAffineMotion","page":"AffineMotions.jl","title":"AffineMotions.FlatAffineMotion","text":"FlatAffineMotion(A::Matrix,b::Vector)\n\nCreates the affine motion corresponding to the vector field x  A x + b.\n\nusing AffineMotions\nA = [0 1.;0 0]\nb = [0, 0]\nmotion = FlatAffineMotion(A,b)\n\nx0 = [2., 10] # position zero, velocity 10\nx1 = integrate(motion, x0)\n# output\n2-element Vector{Float64}:\n 12.0\n 10.0\n\n\n\n\n\n","category":"type"},{"location":"#AffineMotions.get_flat_action-Tuple{Any}","page":"AffineMotions.jl","title":"AffineMotions.get_flat_action","text":"get_flat_action(d)\n\nThe action associated to a flat space of dimension d, namely a translation group acting on a Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#Rigid-Motions","page":"AffineMotions.jl","title":"Rigid Motions","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/Rigid.jl\"]","category":"page"},{"location":"#AffineMotions.RigidMotion","page":"AffineMotions.jl","title":"AffineMotions.RigidMotion","text":" RigidMotion(action::Action, Î¾)\n\nThe rigid motion action of a group on a manifold. The variable Î¾ is an element of the Lie algebra of the acting group base_group(action).\n\nThe corresponding vector field f at a point x of the manifold M (i.e., M := group_manifold(action)) is:\n\nf(x) = Î¾x\n\nwhere  represents the infinitesimal action defined by action.\n\n\n\n\n\n","category":"type"},{"location":"#AffineMotions.get_velocity","page":"AffineMotions.jl","title":"AffineMotions.get_velocity","text":" get_velocity(m::AbstractRigidMotion)\n\nAccess to the underlying infinitesimal motion defining the rigid motion m.\n\n\n\n\n\n","category":"function"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/Zero.jl\"]","category":"page"},{"location":"#AffineMotions.ZeroMotion","page":"AffineMotions.jl","title":"AffineMotions.ZeroMotion","text":"ZeroMotion(::GroupAction)\n\nTrivial rigid motion equal to zero everywhere.\n\n\n\n\n\n","category":"type"},{"location":"#Translations","page":"AffineMotions.jl","title":"Translations","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Simple/Translation.jl\"]","category":"page"},{"location":"#AffineMotions.TranslationMotion-Tuple{Any, Any, Manifolds.GroupActionSide}","page":"AffineMotions.jl","title":"AffineMotions.TranslationMotion","text":"TranslationMotion(G, Î¾, side=LeftSide())\n\nA translation motion Ï†  G  Alg(G) defined on Lie groups. There is a left and a right version.\n\nLeft: Ï†(Ï‡) = -Ï‡Î¾Ï‡^-1.\nRight: Ï†(Ï‡) = -Ï‡^-1Î¾Ï‡.\n\nIn both cases, the linear part is the zero operator.\n\n\n\n\n\n","category":"method"},{"location":"#Adjoint-Linear-Motion","page":"AffineMotions.jl","title":"Adjoint Linear Motion","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"../ext/AdjointLinearExt/AdjointLinear.jl\"]","category":"page"},{"location":"#Utilities","page":"AffineMotions.jl","title":"Utilities","text":"","category":"section"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"Modules = [AffineMotions]\nOrder = [:type, :function]\nPages = [\"Utils.jl\"]","category":"page"},{"location":"#AffineMotions.pose_velocities-Tuple{Any, Any}","page":"AffineMotions.jl","title":"AffineMotions.pose_velocities","text":"pose_velocities(G, poses)\n\nTake a list Ï‡_i and returns a list (Ï‡_i v_i)  such that Ï‡_i+1 = exp_Ï‡_i(v_i)\n\n\n\n\n\n","category":"method"},{"location":"#AffineMotions.rigid_motion-NTuple{4, Any}","page":"AffineMotions.jl","title":"AffineMotions.rigid_motion","text":"rigid_motion(G, Ï‡, v, side)\n\nThe rigid motion starting at Ï‡ in the direction v (tangent to Ï‡), using either the standard left action or the dual one.\n\n\n\n\n\n","category":"method"},{"location":"","page":"AffineMotions.jl","title":"AffineMotions.jl","text":"AffineMotions.AdjointLinearMotion","category":"page"},{"location":"#AffineMotions.AdjointLinearMotion","page":"AffineMotions.jl","title":"AffineMotions.AdjointLinearMotion","text":"AdjointLinearMotion(G::DecoratedManifold,M::Array{ð”½, 2},conv::ActionDirection)\n\nOne of the affine motions which are neither rigid motions nor translations on the group SE_k(n) (or more general affine groups). If a group element is denoted by Ï‡ = XR, then the motion corresponding to the kk matrix M is defined by Ï†(Ï‡) = (XM^*0).\n\n\n\n\n\n","category":"type"}]
}
